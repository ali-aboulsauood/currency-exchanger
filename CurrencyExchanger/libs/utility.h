/*
C++ Custom Utility Functions Library v0.0

By:
Ali Aboul Sauood
Gmail:	aliaboulsauood@gmail.com
GitHub:	https://github.com/ali-aboulsauood
*/

#pragma once

#include <iostream>
#include <cstdlib>
#include <stdexcept>
#include <ctime>
#include <utility>
#include <algorithm>
#include <string>
#include <vector>

// The minimum value that can be generated by the pseudo-random number generator used by this library.
#define RAND_MIN (-RAND_MAX)

// Utility Functions Class Library
class utility
{
	// Class constructor: labelled as (private) to prevent instantiation of the class.
	utility() {};

public:
	// The default seed for the pseudo-random number generator used by this library.
	static const unsigned int default_seed = 1u;

	// The minimum ASCII value of a character
	static const int char_min = 0;
	// The maximum ASCII value of a character
	static const int char_max = 127;

	// The minimum ASCII value of an uppercase alphabetic character
	static const int alpha_u_min = 65;
	// The maximum ASCII value of an uppercase alphabetic character
	static const int alpha_u_max = 90;

	// The minimum ASCII value of a lowercase alphabetic character
	static const int alpha_l_min = 97;
	// The maximum ASCII value of a lowercase alphabetic character
	static const int alpha_l_max = 122;

	// The minimum ASCII value of a numeric character
	static const int num_min = 48;
	// The maximum ASCII value of a numeric character
	static const int num_max = 57;

	// Number of characters representing punctuation marks
	static const int punct_count = 32;

	// Number of hexadecimal digits
	static const int xdigit_count = 16;

	// The minimum ASCII value of a printable character
	static const int print_min = 32;
	// The maximum ASCII value of a printable character
	static const int print_max = 126;

	// The minimum ASCII value of a character of graphical representation
	static const int graph_min = 33;
	// The maximum ASCII value of a character of graphical representation
	static const int graph_max = 126;

	// Common character types
	enum CharType { all = 0, alphabetic = 1, uppercase = 2, lowercase = 3, numeric = 4, alphanumeric = 5, alphanumeric_u = 6, alphanumeric_l = 7, xdigit = 8, punct = 9, print = 10, graph = 11 };

	// NOTE: Character types currently supported do not include blank and control characters.

	// Alphabetic character cases
	enum class AlphaCharCase : int { all = -1, uppercase = 0, lowercase = 1 };

	// Characters representing punctuation marks
	static const char PunctChars[];

	// Characters representing hexadecimal digits
	static const char xdigits[];

	// Whitespace Character Types
	enum class Whitespace : char { space = ' ', tab = '\t', newline = '\n', v_tab = '\v', feed = '\f', carriage_return = '\r' };

	// Random Generator Class
	class random
	{
	private:
		// Class constructor: labelled as (private) to prevent instantiation of the class.
		random() {};

		// Throws an exception if a given C++ STL container is empty.
		template <typename container> static void ValidateContainer(const container& _cont)
		{
			if (_cont.empty())
				throw std::invalid_argument("cannot accept an empty container as argument");
		}

	public:
		// (1) Functions that initialize the pseudo-random number generator

		// initializes ("seeds") the pseudo-random number generator using a non-negative integer value (equal to the current Unix timestamp by default). A value of (1) reinitializes the generator, returning it to its state before any seeding operations.
		static void SeedGenerator(unsigned seed = unsigned(std::time(NULL)))
		{
			std::srand(seed);
		}
		// reinitializes the pseudo-random number generator, returning it to its state before any seeding operations.
		static void ResetGenerator()
		{
			SeedGenerator(default_seed);
		}

		// (2) Functions that generate pseudo-random values

		// (A) Functions that generate pseudo-random integers (int)

		// generates a pseudo-random integer number between (and, by default, including) two given integer numbers (by default, they are equal to the minimum and the maximum number that can be generated by the pseudo-random number generator).
		static int RandIntInRange(int min = RAND_MIN, int max = RAND_MAX, bool isInclusive = true)
		{
			/*
			Let (l) be the length of the range from which the desired number(s) is/are generated, and (a) be the first value in the said range, then a random non-negative integer in the said range will be equal to (std :: rand() % l) - a
			Also if (b) is the last value in the said range, then l = b - a + 1.
			*/

			if (min == max)
				return min;

			swap::swap_if(min, max, min > max);

			if (!isInclusive)
			{
				min++;
				max--;
			}

			return (std::rand() % (max - min + 1)) + min;
		}
		// generates a pseudo-random integer number between (and, by default, including) two given integer numbers (by default, they are equal to the minimum and the maximum number that can be generated by the pseudo-random number generator).
		static int RandIntInInterval(int min = RAND_MIN, int max = RAND_MAX, bool includeMin = true, bool includeMax = true)
		{
			if (!includeMin)
				min++;

			if (!includeMax)
				max--;

			return RandIntInRange(min, max);
		}
		// generates a pseudo-random number smaller than (or equal to, if (includeLimit) is equal to (true)) a given integer number.
		static int RandIntBelow(int limit, bool includeLimit = false)
		{
			if (!includeLimit)
				limit--;

			return RandIntInRange(RAND_MIN, limit);
		}
		// generates a pesudo-random integer number greater than (or equal to, if (includeLimit) is equal to (true)) a given integer number.
		static int RandIntAbove(int limit, bool includeLimit = false)
		{
			if (!includeLimit)
				limit++;

			return RandIntInRange(limit, RAND_MAX);
		}

		// (B) Functions that generate pseudo-random characters (char)

		// generates a peseudo-random character between (and, by default, including) two given ASCII values (the minimum and maximum ASCII values by default).
		static char RandCharInRange(int start = char_min, int end = char_max, bool isInclusive = true)
		{
			return char(RandIntInRange(start, end, isInclusive));
		}
		// generates a peseudo-random character between (and, by default, including) two given ASCII values (the minimum and maximum ASCII values by default).
		static char RandCharInInterval(int start = char_min, int end = char_max, bool includeStart = true, bool includeEnd = true)
		{
			return char(RandIntInInterval(start, end, includeStart, includeEnd));
		}
		// generates a pseudo-random character of ASCII value smaller than (or equal to, if (isInclusive) is equal to (true)) a given ASCII value.
		static char RandCharBelow(int limit, bool includeLimit = false)
		{
			if (!includeLimit)
				limit--;

			return RandCharInRange(char_min, limit);
		}
		// generates a pseudo-random character of ASCII value greater than (or equal to, if (isInclusive) is equal to (true)) a given ASCII value.
		static char RandCharAbove(int limit, bool isInclusive = false)
		{
			if (!isInclusive)
				limit++;

			return RandCharInRange(limit, char_max);
		}
		
		// (B - 1) Functions that generate pseudo-random characters (char) of specific types

		// generates a pseudo-random uppercase alphabetic character.
		static char RandUppercaseChar()
		{
			return RandCharInRange(alpha_u_min, alpha_u_max);
		}
		// generates a pseudo-random lowercase alphabetic character.
		static char RandLowercaseChar()
		{
			return RandCharInRange(alpha_l_min, alpha_l_max);
		}
		// generates a pseudo-random alphabetic character of a given type (lowercase, uppercase, or either) (default is either type, indicated by (AlphaCharCase::all)).
		static char RandAlphaChar(AlphaCharCase CharCase = AlphaCharCase::all)
		{
			switch (CharCase)
			{
			case AlphaCharCase::uppercase:
				return RandUppercaseChar();
			case AlphaCharCase::lowercase:
				return RandLowercaseChar();
			default:
				return RandAlphaChar(AlphaCharCase(RandIntInRange(int(AlphaCharCase::uppercase), int(AlphaCharCase::lowercase))));
			}
		}
		// generates a pseudo-random numeric character (a character representing a decimal digit).
		static char RandNumChar()
		{
			return RandCharInRange(num_min, num_max);
		}
		// generates a pseudo-random alphanumeric character, where alphabetic characters are uppercase.
		static char RandAlphaNumChar_uppercase()
		{
			return RandAlphaNumChar(AlphaCharCase::uppercase);
		}
		// generates a pseudo-random alphanumeric character, where alphabetic characters are lowercase.
		static char RandAlphaNumChar_lowercase()
		{
			return RandAlphaNumChar(AlphaCharCase::lowercase);
		}
		// generates a pseudo-random alphanumeric character (the type of the alphabetic character, whether lowercase, uppercase, or either, can be set. It is either case by default).
		static char RandAlphaNumChar(AlphaCharCase CharCase = AlphaCharCase::all)
		{
			// Represents whether a numeric character shall be generated
			bool GenerateNumChar = RandBool();

			return (GenerateNumChar ? RandNumChar() : RandAlphaChar(CharCase));
		}
		// generates a pseudo-random character representing a punctuation mark.
		static char RandPunctChar()
		{
			return PickRandomValueFrom(PunctChars, size_t(punct_count));
		}
		// generates a pseudo-random pintable character.
		static char RandPrintChar()
		{
			return RandCharInRange(print_min, print_max);
		}
		// generates a pseudo-random character of graphical representation.
		static char RandGraphChar()
		{
			return RandCharInRange(graph_min, graph_max);
		}
		// generates a pseudo-random character representing a hexadecimal digit.
		static char RandHexDigit()
		{
			return PickRandomValueFrom(xdigits, size_t(xdigit_count));
		}

		// generates a pseudo-random character of a given type (default is any of the types indicated by enumerators of (CharType)).
		static char RandChar(CharType CharacterType = CharType::all)
		{
			switch (CharacterType)
			{
			case CharType::alphabetic:
				return RandAlphaChar();
			case CharType::uppercase:
				return RandUppercaseChar();
			case CharType::lowercase:
				return RandLowercaseChar();
			case CharType::numeric:
				return RandNumChar();
			case CharType::alphanumeric:
				return RandAlphaNumChar();
			case CharType::alphanumeric_u:
				return RandAlphaNumChar_uppercase();
			case CharType::alphanumeric_l:
				return RandAlphaNumChar_lowercase();
			case CharType::xdigit:
				return RandHexDigit();
			case CharType::punct:
				return RandPunctChar();
			case CharType::print:
				return RandPrintChar();
			case CharType::graph:
				return RandGraphChar();
			default:
				return RandChar(CharType(RandIntInRange(1, 9)));
			}
		}

		// (C) Functions that generate pseudo-random boolean values

		// generates a pseudo-random boolean value.
		static bool RandBool()
		{
			return bool(RandIntInRange(0, 1));
		}

		// (D) Functions that pick pseudo-random values from arrays and C++ STL containers

		// returns a pseudo-random value from a given C-style array of values of a given size.
		template <typename T> static T PickRandomValueFrom(T* arr, int arr_size)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not return a random value from an empty container.");

			int i = RandIntInInterval(0, arr_size, true, false);

			return arr[i];
		}
		// returns a pseudo-random value from a given sequence container of values.
		template <typename container> static typename container::value_type PickRandomValueFrom(const container& _container)
		{
			ValidateContainer(_container);

			int i = RandIntInInterval(0, _container.size(), true, false);

			return _container.at(i);
		}

		// (E) Functions that return or fill C-style arrays and C++ STL containers (except lists, forward lists and deques) with pseudo-random values

		// (E - 1 - A) Functions that return C-style arrays with pseudo-random values.

		// (E - 1 - A - 1) Integers (int)

		// fills a given C-style array with pseudo-random integer values between (and, by default, including) two given integer numbers (by default, they are equal to the minimum and the maximum number that can be generated by the pseudo-random number generator).
		static void FillWithRandomIntegersInRange(int* arr, size_t arr_size, int min = RAND_MIN, int max = RAND_MAX, bool isInclusive = true)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			for (size_t i = 0ull; i < arr_size; i++)
				arr[i] = RandIntInRange(min, max, isInclusive);
		}
		// fills a given C-style array with pseudo-random integer values between (and, by default, including) two given integer numbers.
		static void FillWithRandomIntegersInInterval(int* arr, size_t arr_size, int min = RAND_MIN, int max = RAND_MAX, bool includeMin = true, bool includeMax = true)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			for (size_t i = 0ull; i < arr_size; i++)
				arr[i] = RandIntInInterval(min, max, includeMin, includeMax);
		}
		// fills a given C-style array with pseudo-random integers that are smaller than (or equal to, if (includeLimit) is equal to (true)) a given integer number.
		static void FillWithRandomIntegersBelow(int* arr, size_t arr_size, int limit, bool includeLimit = false)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			if (!includeLimit)
				limit--;

			FillWithRandomIntegersInRange(arr, arr_size, RAND_MIN, limit);
		}
		// fills a given C-style array with pseudo-random integers that are greater than (or equal to, if (includeLimit) is equal to (true)) a given integer number.
		static void FillWithRandomIntegersAbove(int* arr, size_t arr_size, int limit, bool includeLimit = false)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			if (!includeLimit)
				limit++;

			FillWithRandomIntegersInRange(arr, arr_size, limit, RAND_MAX);
		}

		// returns a C-style array of pseudo-random integer values between (and, by default, including) two given integer numbers (by default, they are equal to the minimum and the maximum number that can be generated by the pseudo-random number generator).
		static int* RandomIntegersInRange(size_t n, int min = RAND_MIN, int max = RAND_MAX, bool isInclusive = true)
		{
			auto arr = new int[n];

			FillWithRandomIntegersInRange(arr, n, min, max, isInclusive);

			return arr;
		}
		// returns a C-style array of pseudo-random integer values between (and, by default, including) two given integer numbers (by default, they are equal to the minimum and the maximum number that can be generated by the pseudo-random number generator).
		static int* RandomIntegersInInterval(size_t n, int min = RAND_MIN, int max = RAND_MAX, bool includeMin = true, bool includeMax = true)
		{
			auto arr = new int[n];

			FillWithRandomIntegersInInterval(arr, n, min, max, includeMin, includeMax);

			return arr;

		}
		// returns a C-style array with pseudo-random integers that are smaller than (or equal to, if (includeLimit) is equal to (true)) a given integer number.
		static int* RandomIntegersBelow(size_t n, int limit, bool includeLimit = false)
		{
			if (!includeLimit)
				limit--;

			return RandomIntegersInRange(n, RAND_MIN, limit);
		}
		// returns a C-style array with pseudo-random integers that are greater than (or equal to, if (includeLimit) is equal to (true)) a given integer number.
		static int* RandomIntegersAbove(size_t n, int limit, bool includeLimit = false)
		{
			if (!includeLimit)
				limit++;

			return RandomIntegersInRange(n, limit, RAND_MAX);
		}

		// fills a given C++ STL container (except lists, forward lists and deques) with pseudo-random integer values between (and, by default, including) two given integer numbers.
		template <typename container> static void FillWithRandomIntegersInRange(container& _container, int min = RAND_MIN, int max = RAND_MAX, bool isInclusive = true)
		{
			ValidateContainer(_container);

			for (size_t i = 0ull; i < _container.size(); i++)
				_container.at(i) = RandIntInRange(min, max, isInclusive);
		}
		// fills a given C++ STL container (except lists, forward lists and deques) with pseudo-random integer values between (and, by default, including) two given integer numbers.
		template <typename container> static void FillWithRandomIntegersInInterval(container& _container, int min = RAND_MIN, int max = RAND_MAX, bool includeMin = true, bool includeMax = true)
		{
			ValidateContainer(_container);

			for (size_t i = 0ull; i < _container.size(); i++)
				_container.at(i) = RandIntInInterval(min, max, includeMin, includeMax);
		}
		// fills a given C++ STL container (except lists, forward lists and deques) with pseudo-random integers that are smaller than (or equal to, if (includeLimit) is equal to (true)) a given integer number.
		template <typename container> static void FillWithRandomIntegersBelow(container& _container, int limit, bool includeLimit = false)
		{
			ValidateContainer(_container);

			if (!includeLimit)
				limit--;

			FillWithRandomIntegersInRange(_container, RAND_MIN, limit);
		}
		// fills a given sequence container (except lists, forward lists and deques) with pseudo-random integers that are greater than (or equal to, if (includeLimit) is equal to (true)) a given integer number.
		template <typename container> static void FillWithRandomIntegersAbove(container& _container, int limit, bool includeLimit = false)
		{
			ValidateContainer(_container);

			if (!includeLimit)
				limit++;

			FillWithRandomIntegersInRange(_container, limit, RAND_MAX);
		}

		// (E - 1 - A - 2) Characters (char)

		// fills a given C-style array with peseudo-random characters between (and, by default, including) two given ASCII values (the minimum and maximum ASCII values, by default).
		static void FillWithRandomCharactersInRange(char* arr, size_t arr_size, int start = char_min, int end = char_max, bool isInclusive = true)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			for (size_t i = 0ull; i < arr_size; i++)
				arr[i] = RandCharInRange(start, end, isInclusive);
		}
		// fills a given C-style array with peseudo-random characters between (and, by default, including) two given ASCII values (the minimum and maximum ASCII values, by default).
		static void FillWithRandomCharactersInInterval(char* arr, size_t arr_size, int start = char_min, int end = char_max, bool includeStart = true, bool includeEnd = true)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			for (size_t i = 0ull; i < arr_size; i++)
				arr[i] = RandCharInInterval(start, end, includeStart, includeEnd);
		}
		// fills a given C-style array with pseudo-random characters of ASCII values smaller than (or equal to, if (includeLimit) is equal to (true)) a given ASCII value.
		static void FillWithRandomCharactersBelow(char* arr, size_t arr_size, int limit, bool includeLimit = false)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			if (!includeLimit)
				limit--;

			FillWithRandomCharactersInRange(arr, arr_size, char_min, limit);
		}
		// fills a given C-style array with pseudo-random characters of ASCII values greater than (or equal to, if (includeLimit) is equal to (true)) a given ASCII value.
		static void FillWithRandomCharactersAbove(char* arr, size_t arr_size, int limit, bool includeLimit = false)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			if (!includeLimit)
				limit++;

			FillWithRandomCharactersInRange(arr, arr_size, limit, char_max);
		}

		// returns a C-style array of pseudo-random characters between (and, by default, including) two given ASCII values (the minimum and maximum ASCII values, by default).
		static char* RandomCharactersInRange(size_t n, int start = char_min, int end = char_max, bool isInclusive = true)
		{
			auto arr = new char[n];

			FillWithRandomCharactersInRange(arr, n, start, end, isInclusive);

			return arr;
		}
		// returns a C-style array of pseudo-random characters between (and, by default, including) two given ASCII values (the minimum and maximum ASCII values, by default).
		static char* RandomCharactersInInterval(size_t n, int start = char_min, int end = char_max, bool includeStart = true, bool includeEnd = true)
		{
			auto arr = new char[n];

			FillWithRandomCharactersInInterval(arr, n, start, end, includeStart, includeEnd);

			return arr;
		}
		// returns a C-style array of pseudo-random characters pseudo-random characters of ASCII values smaller than (or equal to, if (includeLimit) is equal to (true)) a given ASCII value.
		static char* RandomCharactersBelow(size_t n, int limit, bool includeLimit = false)
		{
			auto arr = new char[n];

			FillWithRandomCharactersBelow(arr, n, limit, includeLimit);

			return arr;
		}
		// returns a C-style array of pseudo-random characters pseudo-random characters of ASCII values smaller than (or equal to, if (includeLimit) is equal to (true)) a given ASCII value.
		static char* RandomCharactersAbove(size_t n, int limit, bool includeLimit = false)
		{
			auto arr = new char[n];

			FillWithRandomCharactersAbove(arr, n, limit, includeLimit);

			return arr;
		}

		// fills a given C++ STL container (except lists, forward lists and deques) with pseudo-random characters between (and, by default, including) two given ASCII values.
		template <typename container> static void FillWithRandomCharactersInRange(container& _container, int start = char_min, int end = char_max, bool isInclusive = true)
		{
			ValidateContainer(_container);

			for (size_t i = 0ull; i < _container.size(); i++)
				_container.at(i) = RandCharInRange(start, end, isInclusive);
		}
		// fills a given C++ STL container (except lists, forward lists and deques) with pseudo-random characters between (and, by default, including) two given integer numbers.
		template <typename container> static void FillWithRandomCharactersInInterval(container& _container, int start = char_min, int end = char_max, bool includeMin = true, bool includeMax = true)
		{
			ValidateContainer(_container);

			for (size_t i = 0ull; i < _container.size(); i++)
				_container.at(i) = RandCharInInterval(start, end, includeMin, includeMax);
		}
		// fills a given C++ STL container (except lists, forward lists and deques) with pseudo-random characters that are smaller than (or equal to, if (includeLimit) is equal to (true)) a given ASCII value.
		template <typename container> static void FillWithRandomCharactersBelow(container& _container, int limit, bool includeLimit = false)
		{
			ValidateContainer(_container);

			if (!includeLimit)
				limit--;

			FillWithRandomCharactersInRange(_container, char_min, limit);
		}
		// fills a given C++ STL container (except lists, forward lists and deques) with pseudo-random characters that are greater than (or equal to, if (isInclusive) is set to (true)) a given ASCII value.
		template <typename container> static void FillWithRandomCharactersAbove(container& _container, int limit, bool includeLimit = false)
		{
			ValidateContainer(_container);

			if (!includeLimit)
				limit++;

			FillWithRandomCharactersInRange(_container, limit, char_max);
		}

		// fills a given C-style array with pseudo-random characters of a given type (default is any of the types indicated by enumerators of (CharType)).
		static void FillWithRandomCharacters(char* arr, size_t arr_size, CharType type = CharType::all)
		{
			if (arr_size == 0ull)
				throw std::invalid_argument("can not fill an empty container.");

			for (size_t i = 0ull; i < arr_size; i++)
				arr[i] = RandChar(type);
		}
		// fills a given C++ STL container (except lists, forward lists and deques) with pseudo-random characters of a given type (default is any of the types indicated by enumerators of (CharType)).
		template <typename container> static void FillWithRandomCharacters(container& _container, CharType type = CharType::all)
		{
			ValidateContainer(_container);

			for (size_t i = 0ull; i < _container.size(); i++)
				_container.at(i) = RandChar(type);
		}

		// (F) Functions that generate random strings

		// generates a pseudo-random string of given length and character type.
		static std::string RandomString(size_t length, CharType CharacterType = CharType::all)
		{
			auto str = std::string();

			for (size_t i = 0ull; i < length; i++)
				str.push_back(RandChar(CharacterType));

			return str;
		}

		// Pseudo-Random Key Generator Class
		class random_key
		{
		private:
			// Class constructor: labelled as (private) to prevent instantiation of the class.
			random_key() {};

		public:
			// generates a pseudo-random key of given (hyphenated, by default) number of segments each of a given length (4 characters by default) and a given type of characters (alphanumeric by default).
			static std::string RandomKey(size_t number_of_segments, size_t length_of_segment = 4ull, CharType character_type = CharType::alphanumeric_u, bool dash_separated = true)
			{
				auto RandomKey = std::string();

				for (size_t i = 0ull; i < number_of_segments; i++)
				{
					RandomKey += RandomString(length_of_segment, character_type);

					if (dash_separated && (i != number_of_segments - 1ull))
						RandomKey.push_back('-');
				}

				return RandomKey;
			}
			
			// fills a given C-style array with pseudo-random keys of given (hyphenated, by default) number of segments each of a given length (4 characters by default) and a given type of characters (alphanumeric by default).
			static void FillWithRandomKeys(std::string* arr, size_t n, size_t number_of_segments, size_t length_of_segment = 4ull, CharType character_type = CharType::alphanumeric_u, bool dash_separated = true)
			{
				for (size_t i = 0ull; i < n; i++)
					arr[i] = RandomKey(number_of_segments, length_of_segment, character_type, dash_separated);
			}
			// returns a C-style array with pseudo-random keys of given (hyphenated, by default) number of segments each of a given length (4 characters by default) and a given type of characters (alphanumeric by default).
			static std::string* RandomKeys(size_t n, size_t number_of_segments, size_t length_of_segment = 4ull, CharType character_type = CharType::alphanumeric_u, bool dash_separated = true)
			{
				auto RandomKeys = new std::string[n];

				FillWithRandomKeys(RandomKeys, n, number_of_segments, length_of_segment, character_type, dash_separated);

				return RandomKeys;
			}
			// fills a given C++ STL container (except lists, forward lists, and deques) with pseudo-random keys of given (hyphenated, by default) number of segments each of a given length (4 characters by default) and a given type of characters (alphanumeric by default).
			template <typename container> static void FillWithRandomKeys(container& _container, size_t number_of_segments, size_t length_of_segment = 4ull, CharType character_type = CharType::alphanumeric_u, bool dash_separated = true)
			{
				ValidateContainer(_container);

				for (size_t i = 0ull; i < _container.size(); i++)
					_container.at(i) = RandomKey(number_of_segments, length_of_segment, character_type, dash_separated);
			}
		};

		// Sequence Container Shuffle Class
		class shuffle
		{
		private:
			// Class constructor: labelled as (private) to prevent instantiation of the class.
			shuffle() {};

		public:
			// returns a shuffled version of a given C-style array.
			template <typename T> static T* Shuffle(T* arr, int arr_size)
			{
				T* arr_ = new T[arr_size];

				std::vector<int> positions_chosen;
				int chosen_pos = 0;

				for (int i = 0; i < arr_size; i++)
				{
					do
					{
						chosen_pos = size_t(RandIntInInterval(0, arr_size, true, false));
					} while (std::find(positions_chosen.begin(), positions_chosen.end(), chosen_pos) != positions_chosen.end());

					arr_[i] = arr[chosen_pos];

					positions_chosen.push_back(chosen_pos);
				}

				return arr_;
			}
			// returns a shuffled version of a given C-style array.
			template <typename T> static T* Shuffle(T* arr, const size_t& arr_size)
			{
				T arr_[arr_size] = arr;

				for (size_t i = 0ull; i < arr_size; i++)
					swap::swap_(arr_[RandIntInRange(0, arr_size - 1ull)], arr_[RandIntInRange(0, arr_size - 1ull)]);

				return arr_;
			}

			// returns a shuffled version of a given C++ STL container (except lists, forward lists, and deques)
			template <typename container> static container Shuffle(const container& cont)
			{
				container cont_ = cont;
				size_t cont_size = cont_.size();

				for (size_t i = 0ull; i < cont_.size(); i++)
					swap::swap_(cont_.at(RandIntInRange(0, cont_size - 1ull)), cont_.at(RandIntInRange(0, cont_size - 1ull)));

				return cont_;
			}
		};
	};

	// Encryption/Decryption Operations Class
	class EncryptDecrypt
	{
	private:
		// Class Constructor. Labelled as (private) to prevent instantiation of the class
		EncryptDecrypt() {}

		// static enum class operation : bool { encrypt = false, decrypt = true };

	public:
		// encrypts/decrypts a given character sequence by replacing each character by the one whose ASCII value is more or less than its own by a given ASCII value (encryption by shifting).
		static std::string EncryptDecrypt_shift(const std::string& text, const int& encryption_key)
		{
			auto text_ = std::string();

			for (const char& character : text)
				text_.push_back(char(int(character) + encryption_key));

			return text_;
		}
	};

	// Swap Class
	class swap
	{
	private:
		// Class constructor: labelled as (private) to prevent instantiation of the class.
		swap() {};

	public:
		// swaps the data contained by two given variables/objects of any data type/class.
		template <typename type> static void swap_(type& obj1, type& obj2)
		{
			type obj1_ = std::move(obj1);

			obj1 = std::move(obj2);
			obj2 = std::move(obj1_);
		};
		// swaps the data contained by two given variables/objects of any data type/class if a given condition is equal to (true).
		template <typename type> static void swap_if(type& obj1, type& obj2, bool condition)
		{
			if (condition)
				swap_(obj1, obj2);
		}
	};

	// Output Class
	class output
	{
	private:
		// Class constructor: labelled as (private) to prevent instantiation of the class.
		output() {};

	public:
		// outputs (std::endl) to the standard console output stream (std::cout)
		static void endline()
		{
			std::cout << std::endl;
		}

		// returns the string representation of a given boolean value.
		static std::string bool_to_str(bool boolean)
		{
			return (boolean ? "true" : "false");
		}

		// generates a string containing a given number of a given character with an optional character separator (sep) and an optional delimiter at the beginning and the end of the string (delim).
		static std::string repeat_char(const char& c, size_t n, std::string sep = std::string(), std::string delim = std::string())
		{
			auto str_ = std::string();

			str_ += delim;

			for (size_t i = 1; i <= n; i++)
			{
				str_.push_back(c);
				if (i != n)
					str_ += sep;
			}

			str_ += delim;

			return str_;
		}
		// generates a string containing a given number of a another given string with an optional substring separator (sep) and an optional delimiter at the beginning and the end of the string (delim)
		static std::string repeat_str(const std::string& str, size_t n, std::string sep = std::string(), std::string delim = std::string())
		{
			auto str_ = std::string();

			str_ += delim;

			for (size_t i = 1; i <= n; i++)
			{
				str_ += str;
				if (i != n)
					str_ += sep;
			}

			str_ += delim;

			return str_;
		}

		// generates a string containing a given number of space characters (' ').
		static std::string spaces(size_t n)
		{
			return std::string(n, ' ');
		}
		// generates a string containing a given number of horizontal tab characters ('\t').
		static std::string tabs(size_t n)
		{
			return std::string(n, '\t');
		}
		// generates a string containing a given number of newline (line feed) characters ('\n').
		static std::string newlines(size_t n)
		{
			return std::string(n, '\n');
		}
		// generates a string containing a given number of a given type of whitespace characters (space, horizontal tab, newline, vertical tab, feed, carriage return).
		static std::string whitespaces(size_t n, Whitespace whitespace)
		{
			return std::string(n, char(whitespace));
		}

		// generates a string containing a number of instances of a given character (a hyphen ('-'), by default) that is equal to the length of a given string. Useful for simple redaction operations.
		static std::string placeholder(std::string text, char character = '-')
		{
			return std::string(text.length(), character);
		}
		// generates an underlined text from a given string using a given character (a hyphen ('-'), by default).
		static std::string underlined_text(std::string text, char character = '-')
		{
			return text + '\n' + placeholder(text, character);
		}

		// generates a string representation of a given C-style array of numeric values. The braces enclosing the array sequence and the separator delimiting its elements can be set.
		template <typename number> static std::string list_numarray(number* arr, size_t arr_size, std::string braces = "{}", std::string sep = ", ")
		{
			auto list = std::string();

			list.push_back(braces.front());
			list.push_back(' ');

			for (size_t i = 0ull; i < arr_size; i++)
			{
				list += std::to_string(arr[i]);

				if (i != arr_size - 1ull)
					list += sep;
			}

			list.push_back(' ');
			list.push_back(braces.back());

			return list;
		}
		// generates a string representation of a given C-style array of characters or strings. The braces enclosing the array sequence and the separator delimiting its elements can be set.
		template <typename str> static std::string list_chararray(str* arr, size_t arr_size, std::string braces = "{}", std::string sep = ", ")
		{
			auto list = std::string();

			list += (braces.front() + ' ');

			for (size_t i = 0ull; i < arr_size; i++)
			{
				list += arr[i];

				if (i != arr_size - 1ull)
					list += sep;
			}

			list += (' ' + braces.back());

			return list;
		}

		// generates a string representation of a given C++ STL sequence container of numeric values (excluding lists, forward lists and deques). The braces enclosing the array sequence and the separator delimiting its elements can be set.
		template <typename container> static std::string list_numcontainer(const container& cont, std::string braces = "{}", std::string sep = ", ")
		{
			auto list = std::string();

			list.push_back(braces.front());
			list.push_back(' ');

			for (size_t i = 0ull; i < cont.size(); i++)
			{
				list += std::to_string(cont.at(i));

				if (i != cont.size() - 1ull)
					list += sep;
			}

			list.push_back(' ');
			list.push_back(braces.back());

			return list;
		}
		// generates a string representation of a given C++ STL sequence container of characters or strings (excluding lists, forward lists and deques). The braces enclosing the array sequence and the separator delimiting its elements can be set.
		template <typename container> static std::string list_charcontainer(const container& cont, std::string braces = "{}", std::string sep = ", ")
		{
			auto list = std::string();

			list.push_back(braces.front());
			list.push_back(' ');

			for (size_t i = 0ull; i < cont.size(); i++)
			{
				list += cont.at(i);

				if (i != cont.size() - 1ull)
					list += sep;
			}

			list.push_back(' ');
			list.push_back(braces.back());

			return list;
		}
	};
};

const char utility::PunctChars[punct_count] = { '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '_', '`', '{', '|', '}', '~' };

const char utility::xdigits[xdigit_count] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };